package com.example.project;

import android.content.Context;
import android.graphics.Paint;
import android.graphics.RectF;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Path;
import android.text.Layout;
import android.text.StaticLayout;
import android.text.TextPaint;
import android.graphics.Typeface;



/**
 * Created by null on 2020-10-08.
 * Copyright Â© 2020 Mapbox. All rights reserved.
 *
 * Generated by PaintCode
 * http://www.paintcodeapp.com
 *
 * @author null
 */
public class SpeedLimitStyleKit {
    
    
    // Resizing Behavior
    public enum ResizingBehavior {
        AspectFit, //!< The content is proportionally resized to fit into the target rectangle.
        AspectFill, //!< The content is proportionally resized to completely fill the target rectangle.
        Stretch, //!< The content is stretched to match the entire target rectangle.
        Center, //!< The content is centered in the target rectangle, but it is NOT resized.
    }
    
    // Canvas Drawings
    // Speed Limits
    
    private static class CacheForMUTCD {
        private static Paint paint = new Paint();
        private static RectF originalFrame = new RectF(0f, 0f, 56f, 66f);
        private static RectF resizedFrame = new RectF();
        private static RectF signBackRect = new RectF();
        private static Path signBackPath = new Path();
        private static RectF borderRect = new RectF();
        private static Path borderPath = new Path();
        private static RectF limitLabelRect = new RectF();
        private static TextPaint limitLabelTextPaint = new TextPaint();
        private static PaintCodeStaticLayout limitLabelStaticLayout = new PaintCodeStaticLayout();
        private static RectF legendLabelRect = new RectF();
        private static TextPaint legendLabelTextPaint = new TextPaint();
        private static PaintCodeStaticLayout legendLabelStaticLayout = new PaintCodeStaticLayout();
    }
    
    public static void drawMUTCD(Canvas canvas, Context context, int signBackColor, int strokeColor, String limit, String legend) {
        SpeedLimitStyleKit.drawMUTCD(canvas, context, new RectF(0f, 0f, 56f, 66f), ResizingBehavior.AspectFit, signBackColor, strokeColor, limit, legend);
    }
    
    public static void drawMUTCD(Canvas canvas, Context context, RectF targetFrame, ResizingBehavior resizing, int signBackColor, int strokeColor, String limit, String legend) {
        // General Declarations
        Paint paint = CacheForMUTCD.paint;
        
        // Local Variables
        float limitFontSize = (float) limit.length() > 2f ? 24f : 32f;
        
        // Resize to Target Frame
        canvas.save();
        RectF resizedFrame = CacheForMUTCD.resizedFrame;
        SpeedLimitStyleKit.resizingBehaviorApply(resizing, CacheForMUTCD.originalFrame, targetFrame, resizedFrame);
        canvas.translate(resizedFrame.left, resizedFrame.top);
        canvas.scale(resizedFrame.width() / 56f, resizedFrame.height() / 66f);
        
        // Sign
        {
            // Sign Back
            RectF signBackRect = CacheForMUTCD.signBackRect;
            signBackRect.set(3f, 3f, 53f, 63f);
            Path signBackPath = CacheForMUTCD.signBackPath;
            signBackPath.reset();
            signBackPath.addRoundRect(signBackRect, 4f, 4f, Path.Direction.CW);
            
            paint.reset();
            paint.setFlags(Paint.ANTI_ALIAS_FLAG);
            paint.setStyle(Paint.Style.FILL);
            paint.setColor(signBackColor);
            canvas.drawPath(signBackPath, paint);
            
            paint.reset();
            paint.setFlags(Paint.ANTI_ALIAS_FLAG);
            paint.setStrokeWidth(4f);
            paint.setStrokeJoin(Paint.Join.BEVEL);
            paint.setStrokeMiter(10f);
            canvas.save();
            paint.setStyle(Paint.Style.STROKE);
            paint.setColor(signBackColor);
            canvas.drawPath(signBackPath, paint);
            canvas.restore();
            
            // Border
            RectF borderRect = CacheForMUTCD.borderRect;
            borderRect.set(3f, 3f, 53f, 63f);
            Path borderPath = CacheForMUTCD.borderPath;
            borderPath.reset();
            borderPath.addRoundRect(borderRect, 4f, 4f, Path.Direction.CW);
            
            paint.reset();
            paint.setFlags(Paint.ANTI_ALIAS_FLAG);
            paint.setStrokeWidth(2f);
            paint.setStrokeJoin(Paint.Join.BEVEL);
            paint.setStrokeMiter(10f);
            canvas.save();
            paint.setStyle(Paint.Style.STROKE);
            paint.setColor(strokeColor);
            canvas.drawPath(borderPath, paint);
            canvas.restore();
        }
        
        // Group
        {
            // Limit Label
            RectF limitLabelRect = CacheForMUTCD.limitLabelRect;
            limitLabelRect.set(3f, 28f, 53f, 63f);
            TextPaint limitLabelTextPaint = CacheForMUTCD.limitLabelTextPaint;
            limitLabelTextPaint.reset();
            limitLabelTextPaint.setFlags(Paint.ANTI_ALIAS_FLAG);
            limitLabelTextPaint.setColor(strokeColor);
            limitLabelTextPaint.setTypeface(Typeface.create((String) null, Typeface.BOLD));
            limitLabelTextPaint.setTextSize(limitFontSize);
            StaticLayout limitLabelStaticLayout = CacheForMUTCD.limitLabelStaticLayout.get((int) limitLabelRect.width(), Layout.Alignment.ALIGN_CENTER, limit, limitLabelTextPaint);
            canvas.save();
            canvas.clipRect(limitLabelRect);
            canvas.translate(limitLabelRect.left, limitLabelRect.top + (limitLabelRect.height() - limitLabelStaticLayout.getHeight()) / 2f);
            limitLabelStaticLayout.draw(canvas);
            canvas.restore();
            
            // Legend Label
            RectF legendLabelRect = CacheForMUTCD.legendLabelRect;
            legendLabelRect.set(3f, 3f, 53f, 28f);
            TextPaint legendLabelTextPaint = CacheForMUTCD.legendLabelTextPaint;
            legendLabelTextPaint.reset();
            legendLabelTextPaint.setFlags(Paint.ANTI_ALIAS_FLAG);
            legendLabelTextPaint.setColor(strokeColor);
            legendLabelTextPaint.setTypeface(Typeface.createFromAsset(context.getAssets(), "SFNSText.ttf"));
            legendLabelTextPaint.setTextSize(17f);
            StaticLayout legendLabelStaticLayout = CacheForMUTCD.legendLabelStaticLayout.get((int) legendLabelRect.width(), Layout.Alignment.ALIGN_CENTER, legend, legendLabelTextPaint);
            canvas.save();
            canvas.clipRect(legendLabelRect);
            canvas.translate(legendLabelRect.left, legendLabelRect.bottom - legendLabelStaticLayout.getHeight());
            legendLabelStaticLayout.draw(canvas);
            canvas.restore();
        }
        
        canvas.restore();
    }
    
    private static class CacheForVienna {
        private static Paint paint = new Paint();
        private static RectF originalFrame = new RectF(0f, 0f, 70f, 70f);
        private static RectF resizedFrame = new RectF();
        private static RectF signBackRect = new RectF();
        private static Path signBackPath = new Path();
        private static RectF inscriptionRect = new RectF();
        private static Path inscriptionPath = new Path();
        private static TextPaint inscriptionTextPaint = new TextPaint();
        private static PaintCodeStaticLayout inscriptionStaticLayout = new PaintCodeStaticLayout();
    }
    
    public static void drawVienna(Canvas canvas, Context context, int signBackColor, int strokeColor, int regulatoryColor, String limit) {
        SpeedLimitStyleKit.drawVienna(canvas, context, new RectF(0f, 0f, 70f, 70f), ResizingBehavior.AspectFit, signBackColor, strokeColor, regulatoryColor, limit);
    }
    
    public static void drawVienna(Canvas canvas, Context context, RectF targetFrame, ResizingBehavior resizing, int signBackColor, int strokeColor, int regulatoryColor, String limit) {
        // General Declarations
        Paint paint = CacheForVienna.paint;
        
        // Local Variables
        float limitFontSize = (float) limit.length() > 2f ? 24f : 32f;
        
        // Resize to Target Frame
        canvas.save();
        RectF resizedFrame = CacheForVienna.resizedFrame;
        SpeedLimitStyleKit.resizingBehaviorApply(resizing, CacheForVienna.originalFrame, targetFrame, resizedFrame);
        canvas.translate(resizedFrame.left, resizedFrame.top);
        canvas.scale(resizedFrame.width() / 70f, resizedFrame.height() / 70f);
        
        // Sign Back
        RectF signBackRect = CacheForVienna.signBackRect;
        signBackRect.set(5f, 5f, 65f, 65f);
        Path signBackPath = CacheForVienna.signBackPath;
        signBackPath.reset();
        signBackPath.addOval(signBackRect, Path.Direction.CW);
        
        paint.reset();
        paint.setFlags(Paint.ANTI_ALIAS_FLAG);
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(signBackColor);
        canvas.drawPath(signBackPath, paint);
        
        paint.reset();
        paint.setFlags(Paint.ANTI_ALIAS_FLAG);
        paint.setStrokeWidth(8f);
        paint.setStrokeMiter(10f);
        canvas.save();
        paint.setStyle(Paint.Style.STROKE);
        paint.setColor(signBackColor);
        canvas.drawPath(signBackPath, paint);
        canvas.restore();
        
        // Inscription
        RectF inscriptionRect = CacheForVienna.inscriptionRect;
        inscriptionRect.set(5f, 5f, 65f, 65f);
        Path inscriptionPath = CacheForVienna.inscriptionPath;
        inscriptionPath.reset();
        inscriptionPath.addOval(inscriptionRect, Path.Direction.CW);
        
        paint.reset();
        paint.setFlags(Paint.ANTI_ALIAS_FLAG);
        paint.setStrokeWidth(6f);
        paint.setStrokeMiter(10f);
        canvas.save();
        paint.setStyle(Paint.Style.STROKE);
        paint.setColor(regulatoryColor);
        canvas.drawPath(inscriptionPath, paint);
        canvas.restore();
        TextPaint inscriptionTextPaint = CacheForVienna.inscriptionTextPaint;
        inscriptionTextPaint.reset();
        inscriptionTextPaint.setFlags(Paint.ANTI_ALIAS_FLAG);
        inscriptionTextPaint.setColor(strokeColor);
        inscriptionTextPaint.setTypeface(Typeface.create((String) null, Typeface.BOLD));
        inscriptionTextPaint.setTextSize(limitFontSize);
        StaticLayout inscriptionStaticLayout = CacheForVienna.inscriptionStaticLayout.get((int) inscriptionRect.width(), Layout.Alignment.ALIGN_CENTER, limit, inscriptionTextPaint);
        canvas.save();
        canvas.clipRect(inscriptionRect);
        canvas.translate(inscriptionRect.left, inscriptionRect.top + (inscriptionRect.height() - inscriptionStaticLayout.getHeight()) / 2f);
        inscriptionStaticLayout.draw(canvas);
        canvas.restore();
        
        canvas.restore();
    }
    
    
    // Resizing Behavior
    public static void resizingBehaviorApply(ResizingBehavior behavior, RectF rect, RectF target, RectF result) {
        if (rect.equals(target) || target == null) {
            result.set(rect);
            return;
        }
        
        if (behavior == ResizingBehavior.Stretch) {
            result.set(target);
            return;
        }
        
        float xRatio = Math.abs(target.width() / rect.width());
        float yRatio = Math.abs(target.height() / rect.height());
        float scale = 0f;
        
        switch (behavior) {
            case AspectFit: {
                scale = Math.min(xRatio, yRatio);
                break;
            }
            case AspectFill: {
                scale = Math.max(xRatio, yRatio);
                break;
            }
            case Center: {
                scale = 1f;
                break;
            }
        }
        
        float newWidth = Math.abs(rect.width() * scale);
        float newHeight = Math.abs(rect.height() * scale);
        result.set(target.centerX() - newWidth / 2,
            target.centerY() - newHeight / 2,
            target.centerX() + newWidth / 2,
            target.centerY() + newHeight / 2);
    }
    
    
}

class PaintCodeStaticLayout {
    private StaticLayout layout;
    private int width;
    private Layout.Alignment alignment;
    private CharSequence source;
    private TextPaint paint;
    
    StaticLayout get(int width, Layout.Alignment alignment, CharSequence source, TextPaint paint) {
        if (this.layout == null || this.width != width || this.alignment != alignment || !this.source.equals(source) || !this.paint.equals(paint)) {
            this.width = width;
            this.alignment = alignment;
            this.source = source;
            this.paint = paint;
            this.layout = new StaticLayout(source, paint, width, alignment, 1, 0, false);
        }
        return this.layout;
    }
}
